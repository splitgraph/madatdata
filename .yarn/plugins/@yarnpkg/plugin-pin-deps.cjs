/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-pin-deps",
factory: function (require) {
var plugin=(()=>{var A=Object.create,b=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames,H=Object.getOwnPropertySymbols,N=Object.getPrototypeOf,R=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable;var T=(t,e,n)=>e in t?b(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,V=(t,e)=>{for(var n in e||(e={}))R.call(e,n)&&T(t,n,e[n]);if(H)for(var n of H(e))z.call(e,n)&&T(t,n,e[n]);return t};var J=t=>b(t,"__esModule",{value:!0});var w=t=>{if(typeof require!="undefined")return require(t);throw new Error('Dynamic require of "'+t+'" is not supported')};var K=(t,e)=>{for(var n in e)b(t,n,{get:e[n],enumerable:!0})},Y=(t,e,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of _(e))!R.call(t,r)&&r!=="default"&&b(t,r,{get:()=>e[r],enumerable:!(n=E(e,r))||n.enumerable});return t},$=t=>Y(J(b(t!=null?A(N(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var F={};K(F,{default:()=>G});var U=$(w("@yarnpkg/cli")),u=$(w("clipanion")),S=$(w("@yarnpkg/cli")),L=$(w("@yarnpkg/fslib")),c=$(w("@yarnpkg/core")),W=$(w("semver")),M=t=>`[32m${t}[0m`,B=t=>`[33m${t}[0m`,x=(t,e)=>{var l,k,d;let{scope:n,name:r,range:s}=t,{highlight:o}=e!=null?e:{},a=p=>p,i={all:typeof o=="function"?o:a,range:(l=o==null?void 0:o.range)!=null?l:a,name:(k=o==null?void 0:o.name)!=null?k:a,scope:(d=o==null?void 0:o.scope)!=null?d:a};return i.all(`${n?`@${i.scope(n)}/`:""}${i.name(r)}:${i.range(s)}`)},P=class extends U.BaseCommand{constructor(){super(...arguments);this.dryRun=u.Option.Boolean("--dry",{description:"Print the changes to stdout but do not apply them to package.json files."});this.onlyDevDependencies=u.Option.Boolean("--only-dev",{description:"Only devDependencies"});this.ignoreDevDependencies=u.Option.Boolean("--ignore-dev",{description:"Ignore devDependencies (default is false, to pin dependencies and devDependencies)."});this.verbose=u.Option.Boolean("--verbose",{description:"Print more information about skipped or already pinned packages"});this.onlyPackages=u.Option.Array("--only",{description:"To _only_ include a specific name:range package (or packages)."});this.alsoIncludePackages=u.Option.Array("--also",{description:"To pin a specific name:range that would otherwise be skipped"});this.onlyWorkspaces=u.Option.Array("--workspace",{description:"To _only_ include a specific workspace (or workspaces)"})}async execute(){this.configuration=await c.Configuration.find(this.context.cwd,(0,S.getPluginConfiguration)());let{project:e}=await c.Project.find(this.configuration,this.context.cwd);this.project=e,this.cache=await c.Cache.find(this.configuration),await this.project.resolveEverything({cache:this.cache,report:new c.ThrowReport}),await c.StreamReport.start({configuration:this.configuration,stdout:this.context.stdout,includeLogs:!0,json:!1},async n=>{this.log=n,this.gatherWorkspaces(),this.createLocatorsByIdentMap(),await this.findPinnableDependencies(),await this.pinDependencies()})}createLocatorsByIdentMap(){let e=new Map;for(let[n,r]of this.project.storedResolutions.entries()){let s=r,a=this.project.storedDescriptors.get(n).identHash,i=e.get(a);i===void 0?e.set(a,new Set([s])):e.set(a,i.add(s))}return this.locatorsByIdent=e,this.locatorsByIdent}gatherWorkspaces(){let e=!this.onlyWorkspaces||this.onlyWorkspaces.length===0;return this.workspaces=e?this.project.workspaces:this.project.workspaces.filter(n=>{var o,a;let r=[n.cwd,n.relativeCwd,(a=(o=n.manifest)==null?void 0:o.name)==null?void 0:a.name].filter(i=>!!i),s=this.onlyWorkspaces.some(i=>r.includes(i));return s?this.log.reportWarning(0,`${M("\u2713")} Including workspace ${n.manifest.name.name} at ${n.cwd}`):this.logVerboseWarning("gatherWorkspaces",`${B("x")} Excluding workspace ${n.manifest.name.name}, no match for ${r.map(i=>`'${i}'`).join(" or ")}`),s}),this.workspaces}async pinDependencies(){this.log.reportJson({type:"info",name:"pinnableDependencies",displayName:"pinnableDependencies",data:this.pinnableJSON});for(let e of this.workspaces){let{manifest:n,cwd:r}=e,s=L.ppath.join(r,c.Manifest.fileName),o=this.pinnableByWorkspaceCwd.get(r),a=0;for(let[l,{version:k}]of o){let d=n.dependencies.get(l),p=n.devDependencies.get(l),g=d!=null?d:p,I=V({},g);if(d&&p&&this.log.reportWarning(0,`Possible package.json conflict between devDependencies and dependencies in ${g.name} at ${s}`),(g==null?void 0:g.range)===k)continue;let y=Object.assign(g,{range:k});d?n.dependencies.set(l,y):p&&n.devDependencies.set(l,y),this.log.reportInfo(0,`${M("\u2192")} Pin ${x(I,{highlight:{range:B}})} \u2192 ${x(y,{highlight:{range:M}})} (${s})`),a=a+1}a>0&&(this.dryRun||await e.persistManifest(),this.log.reportInfo(0,`${M("\u2713")} Pinned ${a} and ${this.dryRun?"saved[DRY RUN]":"saved"} to ${s}`))}}static referencesPackage(e,{scope:n,name:r,range:s}){let o=x({scope:n,name:r,range:s}),a=e===o,i=[`:${s}`,`*:${s}`].includes(e);return a||i}isDependencyExplicitlyIncluded({scope:e,name:n,range:r}){var a,i;let s=((a=this.alsoIncludePackages)!=null?a:[]).some(l=>P.referencesPackage(l,{scope:e,name:n,range:r})),o=((i=this.onlyPackages)!=null?i:[]).some(l=>P.referencesPackage(l,{scope:e,name:n,range:r}));return s||o}logVerboseWarning(e,n){if(!!this.verbose)return this.log.reportWarning(0,`${e} ${n}`)}logVerboseInfo(e,n){if(!!this.verbose)return this.log.reportInfo(0,`${e} ${n}`)}async findPinnableDependencies(){this.pinnableByWorkspaceCwd=new Map,this.reportablePinsByWorkspaceCwd=new Map;for(let{manifest:{dependencies:e,devDependencies:n},cwd:r}of this.workspaces){let s=new Map;this.pinnableByWorkspaceCwd.set(r,s);let o=new Map;if(this.reportablePinsByWorkspaceCwd.set(r,o),!this.onlyDevDependencies)for(let[a,i]of e)this.processDependency([a,i],{workspaceCwd:r,pinnableInWorkspace:s,reportablePinsInWorkspace:o,isDevDependency:!1});if(this.onlyDevDependencies||!this.ignoreDevDependencies)for(let[a,i]of n)this.processDependency([a,i],{workspaceCwd:r,pinnableInWorkspace:s,reportablePinsInWorkspace:o,isDevDependency:!0})}}processDependency([e,n],r){let{workspaceCwd:s,pinnableInWorkspace:o,reportablePinsInWorkspace:a,isDevDependency:i=!1}=r,{scope:l,name:k,range:d}=n,p=x({scope:l,name:k,range:d}),g=this.isDependencyExplicitlyIncluded({name:k,range:d});if(!P.needsPin(d)&&(g?this.logVerboseInfo(`${s}`,`Include: ${p}`):this.logVerboseWarning(`${s}`,`Skip: ${p}`),!g))return;if(this.onlyPackages&&!this.onlyPackages.includes(p)){this.logVerboseWarning(`${s}`,`Omit: ${p}`);return}let I=d.match(/^(.*)$/),y=this.locatorsByIdent.get(e),m;if(y!==void 0&&y.size>1){let v=Array.from(y).map(f=>{let h=this.project.storedPackages.get(f);if(h===void 0)throw new TypeError(`Can't find package for locator hash '${f}'`);if(c.structUtils.isVirtualLocator(h)){let D=c.structUtils.devirtualizeLocator(h);return this.project.storedPackages.get(D.locatorHash)}return h}).filter(f=>!f||(f==null?void 0:f.version)===null?!1:g?!0:I===null?!1:(0,W.satisfies)(f.version,I[1])).sort((f,h)=>g||(0,W.gt)(f.version,h.version)?-1:1);if(v.length>1){let f=v.map((D,C)=>v.slice(C+1).map(O=>[D,O])).flat(),h=0;for(let[D,C]of f)c.structUtils.areLocatorsEqual(D,C)||(h=h+1);h>0&&this.log.reportWarningOnce(0,`Possible duplicate: ${p} has ${v.length} candidates (${h} conflicting pairs) in workspace ${s}`)}m=this.project.storedPackages.get(v[0].locatorHash)}else(y==null?void 0:y.size)===1?m=this.project.storedPackages.get(Array.from(y)[0]):this.log.reportWarning(0,`Missing locator: ${p}, in workspace ${s}`);m.version===d?g?this.log.reportInfo(0,`${B("-")} Already pinned: ${p}`):this.logVerboseWarning(`${s}`,`already pinned ${p} to ${m.version}`):(o.set(e,m),a.set(p,m.version),this.logVerboseInfo(`${s}`,`will pin ${p} to ${m.version} in ${s}`))}get pinnableJSON(){let e=(n=new Map)=>Object.fromEntries(Array.from(n.entries(),([r,s])=>s instanceof Map?[r,e(s)]:[r,s]));return e(this.reportablePinsByWorkspaceCwd)}static needsPin(e){return!!c.semverUtils.validRange(e)}},j=P;j.paths=[["pin-deps"]];j.usage=u.Command.Usage({description:"pin-deps [--dry] [--include name:range]",details:"\n        Pin any unpinned dependencies to their currently resolved version.\n        Pass `--dry` for a dry-run. Otherwise, write changes to `package.json`\n        files directly. You will still need to `yarn install` for the changes\n        to take effect.\n        Search all workspaces by default. Pass `--workspace` flag(s) to focus\n        on one or multiple workspace(s).\n        Search all packages with semver range references by default. To include\n        otherwise skipped packages, specify `--include name:range`. To focus\n        only on specific package(s), specify `--only name:range`\n      ",examples:[[`Update package.json in every workspace, to pin all packages with
          semver range to their currently resolved version.`,"$0 pin-deps"],[`Perform a "dry run" \u2013 do not apply any changes to files, but otherwise
          run command as normally.`,"$0 pin-deps --dry"],["Include (do not skip) any packages with reference next:canary","$0 pin-deps --include next:canary"],["Include any package with range `canary` (not a regex, only works for this syntax)","$0 pin-deps --include :canary"],["Include _only_ packages with reference next:canary or material-ui/core:latest","$0 pin-deps --only next:canary --only material-ui/core:latest"],["Include _only_ workspaces by matching one of workspace.name, workspace.cwd, or workspace.relativeCwd","$0 pin-deps --workspace acmeco/design --workspace acmeco/auth"],["Ignore devDependencies (pin only regular dependencies)","$0 pin-deps --ignore-dev"],["Pin only devDependencies in acmeco/design or acmeco/components","$0 pin-deps --only-dev --workspace acmeco/design --workspace acmeco/components"],["Hacky: print a specific package resolution (`yarn why` or `yarn info` is likely better)","$0 pin-deps --dry --workspace @acmeco/design --only next:canary"],["Print verbose logs (including alerady pinned packages)","$0 --verbose"]]});var q={commands:[j]},G=q;return F;})();
return plugin;
}
};
